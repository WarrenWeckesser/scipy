<h1 id="a-design-specification-for-nan_policy">A Design Specification for <span class="title-ref">nan_policy</span></h1>
<p>Many functions in <span class="title-ref">scipy.stats</span> have a parameter called <code>nan_policy</code> that determines how the function handles data that contains <code>nan</code>. In this section, we provide SciPy developer guidelines for how <code>nan_policy</code> is intended to be used, to ensure that as this parameter is added to new functions, we maintain a consistent API.</p>
<h2 id="the-basic-api">The basic API</h2>
<p>The parameter <code>nan_policy</code> accepts three possible strings: <code>'omit'</code>, <code>'raise'</code> and <code>'propagate'</code>. The meanings are:</p>
<ul>
<li><p><code>nan_policy='omit'</code>: Ignore occurrences of <code>nan</code> in the input. Do not generate a warning if the input contains <code>nan</code>. For example, for the simple case of a function that accepts a single array (and ignoring the possible use of <code>axis</code> for the moment):</p>
<pre><code>func([1.0, 3.0, np.nan, 5.0], nan_policy=&#39;omit&#39;)</code></pre>
<p>should behave the same as:</p>
<pre><code>func([1.0, 3.0, 5.0])</code></pre>
<p>More generally, <code>func(a, nan_policy='omit')</code> should behave the same as <code>func(a[~np.isnan(a)])</code>.</p>
<p>Unit tests for this property should be used to test functions that handle <code>nan_policy</code>.</p>
<p>For functions that accept two or more arguments but whose values are not related, the same idea applies to each input array. So:</p>
<pre><code>func(a, b, nan_policy=&#39;omit&#39;)</code></pre>
<p>should behave the same as:</p>
<pre><code>func(a[~np.isnan(a)], b[~np.isnan(b)])</code></pre>
<p>For inputs with <em>related</em> or <em>paired</em> values, the recommended behavior is to omit all the values for which any of the related values are <code>nan</code>. For a function with two related array inputs, this means:</p>
<pre><code>y = func(a, b, nan_policy=&#39;omit&#39;)</code></pre>
<p>should behave the same as:</p>
<pre><code>hasnan = np.isnan(a) | np.isnan(b)  # Union of the isnan masks.
y = func(a[~hasnan], b[~hasnan])</code></pre>
<p>The docstring for such a function should clearly state this behavior.</p></li>
<li><code>nan_policy='raise'</code>: Raise a <code>ValueError</code>.</li>
<li><p><code>nan_policy='propagate'</code>: Propagate the <code>nan</code> value to the output. Typically, this means just execute the function without checking for <code>nan</code>, but see</p>
<blockquote>
<p><a href="https://github.com/scipy/scipy/issues/7818" class="uri">https://github.com/scipy/scipy/issues/7818</a></p>
</blockquote>
<p>for an example where that might lead to unexpected output.</p></li>
</ul>
<h2 id="nan_policy-combined-with-an-axis-parameter"><code>nan_policy</code> combined with an <code>axis</code> parameter</h2>
<p>There is nothing surprising here--the principle mentioned above still applies when the function has an <code>axis</code> parameter. Suppose, for example, <code>func</code> reduces a 1-d array to a scalar, and handles n-d arrays as a collection of 1-d arrays, with the <code>axis</code> parameter specifying the axis along which the reduction is to be applied. If, say:</p>
<pre><code>func([1, 3, 4])     -&gt; 10.0
func([2, -3, 8, 2]) -&gt;  4.2
func([7, 8])        -&gt;  9.5
func([])            -&gt; -inf</code></pre>
<p>then:</p>
<pre><code>func([[  1, nan,   3,   4],
      [  2,  -3,   8,   2],
      [nan,   7, nan,   8],
      [nan, nan, nan, nan]], nan_policy=&#39;omit&#39;, axis=-1)</code></pre>
<p>must give the result:</p>
<pre><code>np.array([10.0, 4.2, 9.5, -inf])</code></pre>
<h2 id="edge-cases">Edge cases</h2>
<p>A function that implements the <code>nan_policy</code> parameter should gracefully handle the case where <em>all</em> the values in the input array(s) are <code>nan</code>. The basic principle described above still applies:</p>
<pre><code>func([nan, nan, nan], nan_policy=&#39;omit&#39;)</code></pre>
<p>should behave the same as:</p>
<pre><code>func([])</code></pre>
<p>In practice, when adding <code>nan_policy</code> to an existing function, it is not unusual to find that the function doesn't already handle this case in a well-defined manner, and some thought and design may have to be applied to ensure that it works. The correct behavior (whether that be to return <code>nan</code>, return some other value, raise an exception, or something else) will be determined on a case-by-case basis.</p>
<h2 id="why-doesnt-nan_policy-also-apply-to-inf">Why doesn't <code>nan_policy</code> also apply to <code>inf</code>?</h2>
<p>Although we learn in grade school that &quot;infinity is not a number&quot;, the floating point values <code>nan</code> and <code>inf</code> are qualitatively different. The values <code>inf</code> and <code>-inf</code> act much more like regular floating point values than <code>nan</code>.</p>
<ul>
<li>One can compare <code>inf</code> to other floating point values and it behaves as expected, e.g. <code>3 &lt; inf</code> is True.</li>
<li>For the most part, arithmetic works &quot;as expected&quot; with <code>inf</code>, e.g. <code>inf + inf = inf</code>, <code>-2*inf = -inf</code>, <code>1/inf = 0</code>, etc.</li>
<li>Many existing functions work &quot;as expected&quot; with <code>inf</code>: <code>np.log(inf) = inf</code>, <code>np.exp(-inf) = 0</code>, <code>np.array([1.0, -1.0, np.inf]).min() = -1.0</code>, etc.</li>
</ul>
<p>So while <code>nan</code> almost always means &quot;something went wrong&quot; or &quot;something is missing&quot;, <code>inf</code> can in many cases be treated as a useful floating point value.</p>
<p>It is also consistent with the NumPy <code>nan</code> functions to not ignore <code>inf</code>:</p>
<pre><code>&gt;&gt;&gt; np.nanmax([1, 2, 3, np.inf, np.nan])
inf
&gt;&gt;&gt; np.nansum([1, 2, 3, np.inf, np.nan])
inf
&gt;&gt;&gt; np.nanmean([8, -np.inf, 9, 1, np.nan])
-inf</code></pre>
<h2 id="how-not-to-implement-nan_policy">How <em>not</em> to implement <code>nan_policy</code></h2>
<p>In the past (and possibly currently), some <code>stats</code> functions handled <code>nan_policy</code> by using a masked array to mask the <code>nan</code> values, and then computing the result using the functions in the <code>mstats</code> subpackage. The problem with this approach is that the masked array code might convert <code>inf</code> to a masked value, which we don't want to do (see above). It also means that, if care is not taken, the return value will be a masked array, which will likely be a surprise to the user if they passed in regular arrays.</p>
